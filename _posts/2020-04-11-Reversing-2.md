---
title: "CPU Architecture"
date: 2020-04-11 16:30:00 +0900
categories: Yaki Reversing
---

# What is CPU?

- CPU : Central Processing Unit
- PC를 제어하기 위한 중앙 제어 장치
- CPU 아키텍쳐마다 Assembly 언어가 모두 다름

***

### CPU 아키텍쳐 (CPU Architecture)
- CPU 아키텍쳐
  - x86-32
  - x86-64
  - Intel 계열, AMD 계열, SPARC 계열, ARM 계열, AVR 계열, ...
- CPU 아키텍쳐 종류에 따른 운영체제 지원
  - 운영체제를 CPU에 맞게 제작 해야 함
  - **Intel** 계열 : Windows, Linux, Unix, Solaris, ...
  - AMD 계열 : Windows, Linux, Unix, Solaris, ...
  - SPARC : Solaris, Unix
  - ARM : Linux(Desktop)
  - AVR : Embedded Device
  - Intel 계열과 AMD계열은 분석이 호환이 됨
- 절차 지향 방식
  - 프로그램을 실행하면 CPU가 명령을 수행하는 위치로 이동
  - 처음 명령을 수행한 위치로 이동하면 다음 명령은 바로 다음 위치
- 데이터 단위
  - BYTE  : 1 byte
  - WORD : 2 byte
  - DWORD : 4 byte
  - QWORD : 8 byte
  - PTR : 메모리 위치 포인터
- Register
  - CPU 내의 저장소
  - 프로세서 내의 고속의 데이터처리를 위한 기억 장소
  - 프로그램 내의 수행중인 연산 결과를 임시적으로 저장
  - 컴퓨터 장치를 제어
  - 범용 레지스터
    - 프로그램이 사용하는 레지스터
        - 16bit : AX, BX, CX, DX, SI, DI, SP, BP
        - 32bit : EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP
        - 64bit : RAX, RBX, RCX, RDX, RSO, RDO, RSP, RBP, R1 ~ 8
    > EAX   12      34      56      78  
    > ​56, 78 : AX  
    > 56 : AH, 78 : AL  
    > EAX, EBX, ECX, EDX : 하위 16 bit및 8bit 레지스터 명칭을 가짐(하위 호환성)  
    > ESI, EDI, ESP, EBP

  - 플레그 레지스터
    - CPU의 연산 결과를 플레그로 표현하는 레지스터
      Flags(ZF, CF, SF, OF, PF, ...)
      32bit FLAGS  ????????????????????????????????
      ZF : 연산의 결과가 0이면 True(1) 아니면 False(0)
      SF : 연산의 결과가 부호 변경이 발생할 경우 True(1) 아니면 False(0)
      PF : 연산의 결과가 짝수이면 True(1) 아니면 False(0)
      ~~~
      if (n <= 5){         # CMP EAX, 5
      
        N이 작거나 같을 때  # JG SHORT 010073B9 (Jump는 조건이 맞지 않을 때 작동)
      
      }
      
      # 그냥 C언어 조건이랑 Assambly 조건이랑 수행 조건은 반대임
      ~~~

  - 인스트럭션 포인터 레지스터
    - CPU가 다음에 실행할 기계어 코드의 위치(주소)를 가리키는 레지스터
    - 자동으로 다음 명령의 주소로 이동 (실행한 기계어 코드의 크기만큼 증가) => 절차지향
    - EIP
  - 세그먼트 레지스터
    - 세그먼트를 저장하는 레지스터
    - CS(코드 영역), DS(데이터 영역), SS, DF, FS, GS
  - 기타 레지스터
    - 디버그 레지스터
    - 제어 레지스터
    - IDT 레지스터
    - LDT 레지스터
    - GDT 레지스터
- Memory Layout
  - Code : 실행할 기계어 영역
  - Data : 전역 변수, 정적 변수, 문자열 상수, ...
  - Heap : 동적 할당(malloc, calloc, new VirtualAlloc, ...)
  - Stack
    - 지역 변수(주 목적), Parameter(인자값), 복귀 주소(Return Address), 스택 쿠키(Stack Guard), SEH(구조화된 예외 핸들러), 문맥 교화(Context Switching)
- 바이트 순서(Byte Ordering), 엔디언(Endianness)
  - 바이트를 배열하는 방법
  - CPU 아키텍쳐 마다 다른 방식을 사용
  - 엔디언 종류
    - 리틀 엔디언(Intel과 AMD계열)
      - 데이터를 바이트 단위로 **역방향**으로 저장
      - 읽을 때는 거꾸로 읽음
      - 연산 처리속도에 적합
      - 메모리에서 값을 읽을 때는 바이트 만큼 반대로 읽어야 함
    - 빅 엔디언(나머지 계열)
      - 데이터를 바이트 단위로 **정방향**으로 저장
      - 데이터 저장에 적합
  - 주소부터 크기만큼 데이터를 저장하고 읽는 순서
    - > char ch = 'a';
      >
      > ​	-> MOV BYTE PTR [01009000], 0x61
      >
      > int n = 5;
      >
      > ​	-> MOV DWORD PTR [01009000], 5
      >
      > 
      >
      > [참고] ch++; 이라는 명령은 아래와 같이 표현 됨
      >
      > ​	MOV EAX, BYTE PTR [01009000]
      >
      > ​	INC	EAX
      >
      > ​	MOV BYTE PTR [01009000], EAX
      >
      > [참고]
      >
      > ​	int *p, char *p에서 값은 포인터의 주소 값이 되기 때문에 포인터 변수의 값은 DWORD로 읽게 됨 -> int형의 변수와 동일함 -> DWORD가 int인지 char 포인터인지 식별 불가 -> 디컴파일이 불가능
      >
      > 
      >
      > MOV DWORD PTR DS:[1009000],12345678
      >
      > 실제 메모리 [1009000]위치에 들어가는 값 : 78 56 34 12